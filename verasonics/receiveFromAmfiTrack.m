function [ t, q, ts ] = receiveFromAmfiTrack( ip_addr, timeout )
% [ t, q, ts ] = receiveFromAmfiTrack( ip_addr, timeout )
% Description:
% The function receives and formats data, received from rupbery pi based
% back end for Amfi track magnetic tracking system. The received data is a
% raw usb package with following structure:
%
%      nbytes: |    4    |  szUSB*nFrames  |     4*nFrames    |
% description: | nFrames |    positions    |    time stamps   |
% nFames [unit32]: numbr of frmaes to receive
% positions  [array of uchar]: received USB package [ szUSB bytes each ]. 
%                each ackage contains 64 bytes and contains positions
%                information such as quaternions and translations
% time stamps [ array of uint32]: time interval in nanoseconds between
%                received frames ( generated by Ruspberry pi )
%
% The data transfer occurs via TCP/IP. Each call of the function intiate
% TCP connection between client and the RuspberryPI with specified in input
% parameters ip address. client is waiting for the connection timeout ms.
% If noconnection have ben accepted withing the specified range of time,
% the connection breaks and function quits with an error.
%
% Input Parameters:
% ip_addr: ip addr of the ruspberry pi
% timeout: specified timeout
%
% Output parameers: 
% t - array of translation vectors 3 x nFrames
% q - array of quaternions 4x nFrames
% ts - array of time stamps [sec] for each received frame

port = 5555;
szUSB = 64; % size of the sinle usb package

jTcpObj = [];

rcvBuf = [];

try
    jTcpObj = jtcp('request',ip_addr,port,'timeout',timeout,'serialize',false);
    
    % receive position buffer
    while length(rcvBuf) < 4
        mssg = jtcp('read',jTcpObj);
        rcvBuf = [ rcvBuf, mssg ];
    end
    nFrames = typecast(rcvBuf(1:4),'uint32');
    nBytesToRead = nFrames*(4+szUSB)+4;
    fprintf('Frames to receive: %i (%i)\n', nFrames, nBytesToRead);
    while length(rcvBuf) < nBytesToRead
        mssg = jtcp('read',jTcpObj);
        rcvBuf = [ rcvBuf, mssg ];
    end
catch
    if ~isempty(jTcpObj), jtcp('close', jTcpObj); end;
    disp('something went wrong');
    return;
end

% first 4 bytes of the mssage is a number of frames
nStartByte = 5;
posBuf = rcvBuf(nStartByte: (nFrames*szUSB+nStartByte));
nStartByte = nStartByte+nFrames*szUSB;
tsBuf = rcvBuf(nStartByte:(length(rcvBuf)));

[ t, q ] = usbdata2pos(typecast(posBuf, 'uint8'), szUSB);
dt = typecast(tsBuf,'int32');

% make a time stamp
ts  = zeros(1,nFrames);
for iFrame = 2:nFrames
    ts(iFrame) = ts(iFrame-1)+double(dt(iFrame))*1e-9;
end

% Interpolate Coordinates with respect to acquisition frames
indexes = [];

for iFrame = 1:nFrames
    if ( t(1,iFrame) < -1e+4 ) || ( t(1,iFrame ) > 1e+4 )||...
          ( t(2,iFrame) < -1e+4 ) || ( t(2,iFrame ) > 1e+4 )|| ...
          ( t(3,iFrame) < -1e+4 ) || ( t(3,iFrame ) > 1e+4 )|| ...
          ( q(1,iFrame) < -1e+4 ) || ( q(1,iFrame ) > 1e+4 )|| ...
          ( q(2,iFrame) < -1e+4 ) || ( q(2,iFrame ) > 1e+4 )|| ...
          ( q(3,iFrame) < -1e+4 ) || ( q(3,iFrame ) > 1e+4 )
      indexes = indexes;
    else
        indexes = [indexes, iFrame];
    end
end

tmpt = t;
tmpq = q;
tmpts = ts;
t = ones(4,length(indexes));
q = zeros(4,length(indexes));
t(1,:) = tmpt(1,indexes);
t(2,:) = tmpt(2,indexes);
t(3,:) = tmpt(3,indexes);
q(1,:) = tmpq(1,indexes);
q(2,:) = tmpq(2,indexes);
q(3,:) = tmpq(3,indexes);
q(4,:) = tmpq(4,indexes);
ts = tmpts(indexes);

end

